<html>
<head>
<title>webgl demo</title>

<script src="lib/three.js"></script>
<script src="lib/jquery-latest.min.js"></script>
<script src="webgl.js"></script>
<script src="lib/stats.min.js"></script>

<script id="vertexShader" type="x-shader/x-vertex">
    varying vec2 merc;

    void main() {
        merc = uv;
        gl_Position = projectionMatrix * 
                      modelViewMatrix * 
                      vec4(position, 1.0);
    }
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
    #define PI  3.1415926535
    #define PI2 6.2831853071

    // lat/lon degrees
    uniform vec2 pole;
    // pixels per earth circumference (undistorted)
    uniform float scale;
    // overzoom is capped at 2^bias
    uniform float bias;

    // projected mercator unit coordinates: lon:[-180,180] => x:[0,1], lat:0 => y:0
    varying vec2 merc;

    uniform sampler2D txtest[16];

    void llr_to_xyz(in vec2 llr, out vec3 xyz) {
        xyz = vec3(cos(llr.s) * cos(llr.t), sin(llr.s) * cos(llr.t), sin(llr.t));
    }

    void xyz_to_llr(in vec3 xyz, out vec2 llr) {
        // don't use asin(z) because of precision issues
        llr = vec2(atan(xyz.y, xyz.x), atan(xyz.z, length(vec2(xyz.x, xyz.y))));
    }

    // remap lat/lon llr to llr_trans, shifting lat/lon 90,0 to coordinates of fake_pole
    void translate_pole(in vec2 llr, in vec2 fake_pole, out vec2 llr_trans) {
        vec2 rpole = radians(fake_pole);
        vec3 xyz;
        llr_to_xyz(llr, xyz);

        float latrot = rpole.t - .5 * PI;
        float lonrot = rpole.s;
        //TODO could replace this matrix mult with a simple addition to lon
        vec3 trans_xyz = mat3( // second, shift (pole lat, 0) to (pole lat, pole lon)
          cos(lonrot), sin(lonrot), 0,
          -sin(lonrot), cos(lonrot), 0,
          0, 0, 1
        ) * mat3( // first, shift lat +90 to pole lat
          cos(latrot), 0, sin(latrot),
          0, 1, 0,
          -sin(latrot), 0, cos(latrot)
        ) * xyz;
        xyz_to_llr(trans_xyz, llr_trans);
    }

    void main() {
        // projected mercator radians: lon:[-180:180] => x:[-pi, pi]
        vec2 merc_rad = (merc + vec2(-.5, 0)) * PI2;
        // geographic coordinates, radians
        vec2 geo_rad = vec2(merc_rad.s, 2. * atan(exp(merc_rad.t)) - .5 * PI);

        // do pole transformation here
        vec2 abs_geo_rad;
        translate_pole(geo_rad, pole, abs_geo_rad);

        // projected mercator coordinates, radians
        vec2 abs_merc_rad = vec2(abs_geo_rad.s, log(tan(.5 * abs_geo_rad.t + .25 * PI)));
        mat3 merc_map_tx = mat3(
          1./PI2, 0, 0,
          0, -1./PI2, 0,
          .5, .5, 1
        );
        // projected mercator quadtree-map coordiantes: lon:[-180,180] => x:[0,1], lat:[-90,90] => y:[+inf,-inf]
        vec2 abs_map = vec2(merc_map_tx * vec3(abs_merc_rad.s, abs_merc_rad.t, 1.));
        abs_map.x = mod(abs_map.x, 1.);

        bool oob = (abs_map.t < 0. || abs_map.t >= 1.);

        if (oob) {
          gl_FragColor = vec4(.7, .7, .7, 1.);
        } else {
          // compensate for the fact the map imagery is mercator projected, and
          // has higher resolution towards the poles
          float base_distortion = cos(abs_geo_rad.t);
          //float base_distortion = 1.; // don't compensate

          float res = PI2 / scale * cos(geo_rad.t); // radians per pixel
          float base_res = PI2 / 256. * base_distortion; // radians per pixel offered by the lowest zoom layer
          float fzoom = log2(base_res / res); // necessary zoom level (on a continuous scale)
          float zoom = ceil(fzoom - bias); // round to a discrete zoom level
          if (zoom < 0.) {
            zoom = 0.;
          }
                     
          vec2 t = abs_map * pow(2., zoom);
          vec2 k = vec2((mod(t.s / 4., 1.), mod((1. - t.t) / 4., 1.)));

          float zz = mod(zoom, 16.);

                     /*

      if (zz == 0.) {
        gl_FragColor = texture2D(txtest[0], k);
      } else if (zz == 1.) {
        gl_FragColor = texture2D(txtest[1], k);
      } else if (zz == 2.) {
        gl_FragColor = texture2D(txtest[2], k);
      } else if (zz == 3.) {
        gl_FragColor = texture2D(txtest[3], k);
      } else if (zz == 4.) {
        gl_FragColor = texture2D(txtest[4], k);
      } else if (zz == 5.) {
        gl_FragColor = texture2D(txtest[5], k);
      } else if (zz == 6.) {
        gl_FragColor = texture2D(txtest[6], k);
      } else if (zz == 7.) {
        gl_FragColor = texture2D(txtest[7], k);
      } else if (zz == 8.) {
        gl_FragColor = texture2D(txtest[8], k);
      } else if (zz == 9.) {
        gl_FragColor = texture2D(txtest[9], k);
      } else if (zz == 10.) {
        gl_FragColor = texture2D(txtest[10], k);
      } else if (zz == 11.) {
        gl_FragColor = texture2D(txtest[11], k);
      } else if (zz == 12.) {
        gl_FragColor = texture2D(txtest[12], k);
      } else if (zz == 13.) {
        gl_FragColor = texture2D(txtest[13], k);
      } else if (zz == 14.) {
        gl_FragColor = texture2D(txtest[14], k);
      } else if (zz == 15.) {
        gl_FragColor = texture2D(txtest[15], k);
      }

*/

                     gl_FragColor = vec4(zoom / 256., 0., 0., 1.);

       //   gl_FragColor = texture2D(txtest[0], vec2(mod(t.s / 4., 1.), mod((1. - t.t) / 4., 1.)));

//          gl_FragColor = vec4(.04 * zoom, .75 * mod(tx + ty, 2.), .75 * mod(tx + ty, 2.), 1);
        }

    }
</script>

<script>

$(document).ready(init2);

</script>

</head>
<body>

<style>

body {
  margin: 0;
}

</style>

</body>
</html>
